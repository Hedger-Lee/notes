# 数据库的概念

## 事务

> **数据库的事务：处理数据的最小的功能模块**

```sql
begin
  执行语句;
end;
```

### 四个特征

#### 原子性

> 独立的最小的功能模块

#### 一致性

> 一个模块中所有的事务应该同时成功或者失败

#### 隔离性

> 模块和事务之间不会互相影响都是完成各自的功能

#### 持久性

> 数据应该是永久保存的

```sql
'''
A-->B:
检查A有没有这么多钱
减去A的金额
加上B的金额
检查AB是否操作成功
'''
```

## 锁

> **锁：一个人在操作某个数据的时候，另一个人不能对这个数据同时进行操作**

### 分类

#### 按修改的范围分类

##### 行锁

> A用户update或者delete某行数据的时候，B用户不能再去对这行数据做任何的更新

##### 表锁

> A用户update或者delete或者insert某行数据的时候，B用户不能去对这个表的结构做修改的

#### 按上锁的主动性来分类

##### 乐观锁

> 默认的日常操作就是乐观锁

##### 悲观锁

> 不做DML操作，但是也要先对数据上锁

```sql
select * from emp where empno=7369 for update;
```

#### 死锁

> 什么是死锁：多个不同的进程，在执行过程中，互相拥有和占用了对方的资源，谁都无法先释放出来

##### 释放锁的操作：

> v$locked_object  存储所有当前数据库的锁的数据
>
> v$session   存储的登录用户的数据

```sql
--1.在表v$locked_object中查询是否存在锁，如果存在锁，查出其对应的对象id object_id 和序列id session_id
select * from v$locked_object; --object_id=74609,session_id=9

--2.根据锁的对象id object_id 在表dba_objects中查询锁的具体信息，可以看到锁住的表名
select * from dba_objects where object_id=74609;

--3.根据锁的序列id session_id 在表v$session中查询上锁用户的登录序列号serial#
select * from v$session where sid=9; --serial#=2065

--4.根据 session_id,serial# 删除对应的锁信息
alter system kill session '9,2065';
```

## 表分区

> **表分区：设置不同的规则，将相同规则的数据存放在一起，目的是节省数据检索的时间**

> **有分区内容的表叫做分区表。**

> **2000W以上数据的表格，就设置分区。**

### 分区表创建

```sql
--基本格式
create table 表名字(
    列名 数据类型 约束条件
)partition by 分区类型(列名)
(
 分区的规则
);
```

#### 范围分区

> 数值相关的列，时间相关的列  range

```sql
--基本格式：
create table 表名(
列名,数据类型,约束条件
...
)partition by range(列名)
(
partition 分区名 values less than(数值),
    ...
partition 分区名 vlaues less than(maxvalue)--其他
);
```

```sql
create table emp_range(

empno number,

ename varchar2(30),

job varchar2(30),

mgr number,

hiredate date,

sal number,

comm number,

deptno number

)partition by range(sal)

(

​    partition sal01 values less than(2000),

​    partition sal02 values less than(3000),

​    partition sal03 values less than(maxvalue)

);
```

#### 列表分区

> 有大量重复值的固定信息的列  list

```sql
--基本格式
create table 表名(
列名,数据类型,约束条件
...
)partition by list(列名)
(
partition 分区名 values(值),
    ...
);
```

```sql
create table emp_list(

empno number,

ename varchar2(30),

job varchar2(30),

mgr number,

hiredate date,

sal number,

comm number,

deptno number

)partition by list(deptno)

(

​    partition d10 values(10),

​    partition d20 values(20),

​    partition d30 values(30) 

);
```

#### 散列分区

> 没有任何规律的数据  hash  根据数据库里面的一个内置的哈希算法，进行数据的随机划分

```sql
--基本格式
create table 表名(
列名,数据类型,约束条件
...
)partition by hash(列名) partitions 分区数量;
```

```sql
create table emp_hash(

empno number,

ename varchar2(30),

job varchar2(30),

mgr number,

hiredate date,

sal number,

comm number,

deptno number

)partition by hash(ename) partitions 4;
```

#### 组合分区

> 用上面三种方法任意组合，将数据划分的更加细致

```sql
--基本格式
create table 表名(
列名,数据类型,约束条件
...
)partition by hash(列名) 
subpartition by range(列名)
(
partition 主分区名 values()
    (
    subpartition 副分区名 values less than(数值),
        ...
    ),
  ...
)
```

```sql
create table emp_complex(

empno number,

ename varchar2(30),

job varchar2(30),

mgr number,

hiredate date,

sal number,

comm number,

deptno number

)partition by list(deptno)  --父分区

subpartition by range(sal)  --子分区

(

  partition dept10 values(10)

  (

​    subpartition sal2000_10 values less than(2000),

​    subpartition sal3000_10 values less than(3000),

​    subpartition salmax_10 values less than(maxvalue)

  ),

  partition dept20 values(20)

  (

​    subpartition sal2000_20 values less than(2000),

​    subpartition sal3000_20 values less than(3000),

​    subpartition salmax_20 values less than(maxvalue)

  ),

  partition dept30 values(30)

  (

​    subpartition sal2000_30 values less than(2000),

​    subpartition sal3000_30 values less than(3000),

​    subpartition salmax_30 values less than(maxvalue)

  )

);
```

#### 查看分区的信息

```sql
select * from user_tab_partitions;
```

